# Spyn — Phase 1 MVP Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the Minimum Viable Tool — a working scroll choreography editor where users can add sections, load a 3D model, create keyframes on a timeline, edit transforms/camera per keyframe, and export a complete YAML spec.

**Architecture:** Four-panel dark-theme editor (Section Builder | 3D Viewport | Properties Panel | Timeline). Zustand stores, types, utils, and constants are already complete. All 4 panel components are empty skeletons that need real implementation. React Three Fiber for 3D, Tailwind for styling, @dnd-kit for drag-and-drop.

**Tech Stack:** React 19 + TypeScript (strict), Tailwind CSS 4, Three.js via R3F, Zustand 5, @dnd-kit, js-yaml, lucide-react, Vitest for testing.

**Relevant Skills:** `spyn-editor-ui`, `r3f-editor-viewport`, `scroll-timeline-editor`, `spyn-3d-animations`, `spyn-yaml-export`

---

## Current State

- **Complete:** Types (`src/types/index.ts`), all 5 Zustand store slices (`src/store/`), utilities (`src/utils/scrollmath.ts`, `presets.ts`, `yamlExporter.ts`), constants (`src/constants/index.ts`), App layout (`src/App.tsx`)
- **Empty skeletons:** All 4 panel components (SectionBuilder, Viewport3D, Timeline, PropertiesPanel)
- **Missing:** Vitest, all tests, interpolation engine, easing functions, validation

---

## Phase 1 Milestones (from Notion spec)

The Notion spec defines Phase 1 MVP as:
- Section builder with preset blocks (drag, reorder, resize)
- 3D viewport with GLB/GLTF model loading
- Basic timeline with single-track keyframes
- Camera controls per keyframe
- Hold zones between keyframes
- Easing dropdown per keyframe
- YAML spec export with natural language descriptions
- Debug overlay with scroll % and transform values

We break this into **6 sub-phases**, each a self-contained deliverable:

| Sub-Phase | Name | Depends On | Tasks |
|-----------|------|------------|-------|
| 1A | Test Infrastructure + Shared UI | Nothing | 6 |
| 1B | Section Builder | 1A | 7 |
| 1C | 3D Viewport | 1A | 8 |
| 1D | Timeline & Interpolation | 1A, 1B | 9 |
| 1E | Properties Panel | 1A, 1D | 7 |
| 1F | Export, Save/Load & Polish | 1B-1E | 6 |

---

## Sub-Phase 1A: Test Infrastructure + Shared UI Components

### Context
Every panel needs shared editor controls (numeric inputs, sliders, dropdowns, color chips). We also need Vitest before writing any tests.

### Task 1A-1: Add Vitest + Testing Dependencies

**Files:**
- Modify: `package.json`
- Create: `vitest.config.ts`
- Create: `src/test/setup.ts`

**Steps:**
1. Install vitest, @testing-library/react, @testing-library/jest-dom, jsdom, @testing-library/user-event
2. Create `vitest.config.ts` with jsdom environment, setup file
3. Create `src/test/setup.ts` importing `@testing-library/jest-dom`
4. Add `"test": "vitest"` and `"test:run": "vitest run"` scripts to package.json
5. Run `npm test -- --run` to verify empty test suite works
6. Commit: `chore: add vitest testing infrastructure`

---

### Task 1A-2: Unit Tests for Existing Utils

**Files:**
- Create: `src/utils/__tests__/scrollmath.test.ts`
- Create: `src/utils/__tests__/presets.test.ts`
- Create: `src/utils/__tests__/yamlExporter.test.ts`

**Steps:**
1. Write tests for `scrollmath.ts`: lerp, clamp, degToRad, radToDeg, getTotalScrollHeight, scrollToSectionProgress, sectionProgressToScroll (edge cases: empty sections, single section, scroll at boundaries)
2. Write tests for `presets.ts`: createSection produces valid Section with correct type/label/color/contentBlocks
3. Write tests for `yamlExporter.ts`: exports valid YAML string, snake_case keys, includes required fields
4. Run tests, all green
5. Commit: `test: add unit tests for scrollmath, presets, yamlExporter`

---

### Task 1A-3: Shared UI — NumericInput Component

**Files:**
- Create: `src/components/ui/NumericInput.tsx`
- Create: `src/components/ui/__tests__/NumericInput.test.tsx`

**Steps:**
1. Write failing test: renders with label, displays value, calls onChange on type
2. Implement `NumericInput` — dark-theme input with label, value, min/max, step, optional unit suffix (e.g., "vw", "deg", "%")
3. Support: arrow key stepping (step), shift+arrow (step*10), direct type
4. Styling: `bg-gray-700 border-gray-600 text-gray-100 text-sm` (per spyn-editor-ui skill)
5. Run tests, verify passing
6. Commit: `feat: add NumericInput shared UI component`

**Interface:**
```typescript
interface NumericInputProps {
  label: string;
  value: number;
  onChange: (value: number) => void;
  min?: number;
  max?: number;
  step?: number;
  unit?: string;
  className?: string;
}
```

---

### Task 1A-4: Shared UI — XYZInput Component

**Files:**
- Create: `src/components/ui/XYZInput.tsx`
- Create: `src/components/ui/__tests__/XYZInput.test.tsx`

**Steps:**
1. Write failing test: renders 3 NumericInputs for X/Y/Z, calls onChange with updated vector
2. Implement `XYZInput` — row of 3 compact NumericInputs with X/Y/Z labels colored red/green/blue
3. Uses NumericInput internally
4. Run tests, verify passing
5. Commit: `feat: add XYZInput shared UI component`

---

### Task 1A-5: Shared UI — Select / Dropdown Component

**Files:**
- Create: `src/components/ui/Select.tsx`
- Create: `src/components/ui/__tests__/Select.test.tsx`

**Steps:**
1. Write failing test: renders options, calls onChange on selection
2. Implement dark-theme `<select>` wrapper with label, matching editor aesthetic
3. Styling: `bg-gray-700 border-gray-600 text-gray-100 text-sm rounded`
4. Run tests, verify passing
5. Commit: `feat: add Select shared UI component`

---

### Task 1A-6: Shared UI — PropertyGroup + Barrel Export

**Files:**
- Create: `src/components/ui/PropertyGroup.tsx`
- Create: `src/components/ui/__tests__/PropertyGroup.test.tsx`
- Create: `src/components/ui/index.ts` (barrel export)

**Steps:**
1. Write failing test: renders title, children, toggles collapse on click
2. Implement `PropertyGroup` — collapsible panel section with chevron icon, dark divider
3. Styling: `border-b border-gray-700`, header `text-xs font-medium text-gray-400 uppercase tracking-wider`
4. Create `src/components/ui/index.ts` barrel exporting all UI components
5. Run tests, verify all UI tests passing
6. Commit: `feat: add PropertyGroup and UI barrel export`

---

## Sub-Phase 1B: Section Builder

### Context
The left panel (280px). Users drag preset sections onto a list, reorder them, resize heights, and manage content blocks. Creates the page structure that keyframes reference.

### Task 1B-1: Section List + SectionCard

**Files:**
- Modify: `src/components/SectionBuilder/SectionBuilder.tsx`
- Create: `src/components/SectionBuilder/SectionCard.tsx`
- Create: `src/components/SectionBuilder/__tests__/SectionBuilder.test.tsx`

**Steps:**
1. Write failing test: renders sections from store, shows empty state when no sections
2. Implement SectionBuilder with scrollable list of SectionCard components
3. SectionCard shows: color chip, label, height in vh, content block count, delete button
4. Empty state: "No sections yet. Add one below."
5. Wire to store: `useStore(s => s.sections)`, `useStore(s => s.removeSection)`
6. Run tests, verify passing
7. Commit: `feat: implement SectionBuilder with section list`

---

### Task 1B-2: Preset Picker

**Files:**
- Create: `src/components/SectionBuilder/PresetPicker.tsx`
- Modify: `src/components/SectionBuilder/SectionBuilder.tsx`

**Steps:**
1. Write failing test: renders all 11 preset buttons, clicking adds section to store
2. Implement PresetPicker as grid of preset type buttons at bottom of Section Builder
3. Each button: colored dot + label (e.g., "Hero Banner", "Features Grid")
4. On click: `addSection(createSection(type))` from store + presets util
5. Run tests, verify section gets added
6. Commit: `feat: add PresetPicker to Section Builder`

---

### Task 1B-3: Drag & Drop Reorder

**Files:**
- Modify: `src/components/SectionBuilder/SectionBuilder.tsx`
- Modify: `src/components/SectionBuilder/SectionCard.tsx`

**Steps:**
1. Wrap section list with @dnd-kit `DndContext` + `SortableContext`
2. Make each SectionCard a `useSortable` item with drag handle
3. On drag end: call `reorderSections(newOrder)` from store
4. Add drag handle icon (lucide `GripVertical`) to SectionCard
5. Verify: can reorder sections by dragging
6. Commit: `feat: add drag-and-drop reorder to Section Builder`

---

### Task 1B-4: Height Resize

**Files:**
- Modify: `src/components/SectionBuilder/SectionCard.tsx`

**Steps:**
1. Add NumericInput for section height (vh) on each SectionCard
2. Wire to `updateSection(id, { height })` from store
3. Min: 50vh, Max: 500vh, Step: 10
4. Shows current height with "vh" suffix
5. Verify: changing height updates store
6. Commit: `feat: add section height resize control`

---

### Task 1B-5: Content Block List

**Files:**
- Create: `src/components/SectionBuilder/ContentBlockItem.tsx`
- Modify: `src/components/SectionBuilder/SectionCard.tsx`

**Steps:**
1. When SectionCard is expanded, show list of content blocks
2. Each ContentBlockItem: type icon + label + position summary + delete button
3. Wire delete to `removeContentBlock(sectionId, blockId)`
4. Collapsed by default, expand on card click
5. Commit: `feat: show content blocks in Section Builder cards`

---

### Task 1B-6: Section Selection

**Files:**
- Modify: `src/components/SectionBuilder/SectionCard.tsx`
- Modify: `src/store/viewportStore.ts` (add selectedSectionId)

**Steps:**
1. Add `selectedSectionId` to viewport store
2. Clicking a SectionCard selects that section (highlighted border)
3. Selected section: `border-indigo-500` instead of `border-gray-700`
4. Selection used by Timeline to highlight the section band
5. Commit: `feat: add section selection to Section Builder`

---

### Task 1B-7: Visual Polish

**Files:**
- Modify: all SectionBuilder components

**Steps:**
1. Panel header with title "Sections" and section count badge
2. Total scroll height display at bottom (sum of vh)
3. Smooth transitions on expand/collapse
4. Keyboard: Delete key removes selected section
5. Run all Section Builder tests
6. Commit: `feat: polish Section Builder UI`

---

## Sub-Phase 1C: 3D Viewport

### Context
The center panel. Loads a GLB/GLTF 3D model, renders it with transforms driven by the current scroll position and keyframe interpolation. Uses React Three Fiber.

**Relevant skill:** `r3f-editor-viewport`

### Task 1C-1: R3F Canvas Setup

**Files:**
- Modify: `src/components/Viewport3D/Viewport3D.tsx`
- Create: `src/components/Viewport3D/Scene.tsx`

**Steps:**
1. Replace skeleton with R3F `<Canvas>` filling the panel
2. Canvas config: `camera={{ position: [0, 2, 5], fov: 50 }}`, `gl={{ antialias: true, alpha: true }}`, `dpr={[1, 2]}`
3. Create Scene.tsx with ambient light (0.4) + two directional lights
4. Dark background: `<color attach="background" args={['#1f2937']} />`
5. Verify: canvas renders, dark background visible
6. Commit: `feat: set up R3F Canvas and Scene`

---

### Task 1C-2: Model Placeholder + Loading

**Files:**
- Create: `src/components/Viewport3D/ModelRenderer.tsx`
- Modify: `src/components/Viewport3D/Scene.tsx`

**Steps:**
1. ModelRenderer: when no model file → wireframe cube placeholder (`boxGeometry` + `meshStandardMaterial color="#6366f1" wireframe`)
2. When model.file exists → `useGLTF(url)` with `<Suspense fallback={<Placeholder />}>`
3. Wire to store: `useStore(s => s.model)`
4. Verify: purple wireframe cube visible
5. Commit: `feat: add ModelRenderer with placeholder cube`

---

### Task 1C-3: Camera Rig

**Files:**
- Create: `src/components/Viewport3D/CameraRig.tsx`
- Modify: `src/components/Viewport3D/Scene.tsx`

**Steps:**
1. CameraRig using `useFrame` + `useThree` from R3F
2. Convert CameraConfig to position via spherical coordinates:
   - `x = distance * cos(elevRad) * sin(orbitRad)`
   - `y = distance * sin(elevRad)`
   - `z = distance * cos(elevRad) * cos(orbitRad)`
3. Apply offset, smooth lerp each frame: `camera.position.lerp(target, 0.08)`
4. Camera looks at model position (or fixed lookAt)
5. Wire to store: camera config from interpolation
6. Commit: `feat: add programmatic CameraRig`

---

### Task 1C-4: Interpolation Engine + Easing Functions

**Files:**
- Create: `src/utils/interpolation.ts`
- Create: `src/utils/easing.ts`
- Create: `src/utils/__tests__/interpolation.test.ts`
- Create: `src/utils/__tests__/easing.test.ts`

**Steps:**
1. Implement all 16 easing functions in `easing.ts` (ref: `.claude/skills/scroll-timeline-editor/references/easing-functions.md`)
2. Tests: each easing returns 0 at t=0, 1 at t=1, monotonic for non-Back
3. Implement `interpolateAtScroll(keyframes, scroll)` in `interpolation.ts`:
   - Returns `{ model: ModelTransform, camera: CameraConfig } | null`
   - Handles: empty, single, before-first, after-last, hold zones, easing
   - Lerps all model + camera properties
4. Tests: single keyframe returns same, two keyframes lerp at midpoint, hold pins values
5. Run all tests
6. Commit: `feat: add interpolation engine and easing functions`

---

### Task 1C-5: Wire Interpolation to Viewport

**Files:**
- Modify: `src/components/Viewport3D/ModelRenderer.tsx`
- Modify: `src/components/Viewport3D/CameraRig.tsx`
- Modify: `src/components/Viewport3D/Scene.tsx`

**Steps:**
1. Scene.tsx: compute `interpolateAtScroll(keyframes, scrollProgress)`
2. Pass model transform to ModelRenderer, camera config to CameraRig
3. ModelRenderer applies: position (vw/vh → world), rotation (deg → rad), scale, opacity
4. Coordinate mapping: `vwToWorld(vw) = (vw - 50) * 0.1`, `vhToWorld(vh) = -(vh - 50) * 0.1`
5. Verify: model moves when scrollProgress changes
6. Commit: `feat: wire interpolation to viewport rendering`

---

### Task 1C-6: Edit/Preview Mode + Toolbar

**Files:**
- Create: `src/components/Viewport3D/GridHelper.tsx`
- Create: `src/components/Viewport3D/ViewportToolbar.tsx`
- Modify: `src/components/Viewport3D/Scene.tsx`

**Steps:**
1. GridHelper: ground grid visible only in edit mode
2. ViewportToolbar: overlay with mode toggle, breakpoint switcher, debug toggle
3. Edit mode: grid, axis helper, wireframe overlays
4. Preview mode: clean render
5. Wire to store: `mode`, `setMode`, `breakpointView`
6. Commit: `feat: add edit/preview mode and viewport toolbar`

---

### Task 1C-7: Debug Overlay

**Files:**
- Create: `src/components/Viewport3D/DebugOverlay.tsx`
- Modify: `src/components/Viewport3D/Viewport3D.tsx`

**Steps:**
1. HTML overlay (not 3D) at bottom-left of viewport
2. Shows: scroll %, section, position/rotation/scale, camera orbit/elevation/distance
3. Semi-transparent dark bg, monospace `text-xs`, only when `showDebugOverlay`
4. Commit: `feat: add debug overlay`

---

### Task 1C-8: Content Block Wireframes

**Files:**
- Create: `src/components/Viewport3D/ContentBlockOverlay.tsx`
- Modify: `src/components/Viewport3D/Scene.tsx`

**Steps:**
1. Render content blocks as semi-transparent planes in 3D
2. Section color at 15% opacity, wireframe edges at full opacity
3. vw/vh → world mapping for position
4. Only when `showWireframes && mode === 'edit'`
5. Commit: `feat: add content block wireframes`

---

## Sub-Phase 1D: Timeline & Interpolation

### Context
The bottom panel. Horizontal timeline mapping scroll 0-1 to section regions, with keyframe diamonds, hold zones, scrub playhead. Scrubbing drives the 3D viewport.

**Relevant skill:** `scroll-timeline-editor`

### Task 1D-1: Timeline Track + Section Bands

**Files:**
- Modify: `src/components/Timeline/Timeline.tsx`
- Create: `src/components/Timeline/TimelineTrack.tsx`
- Create: `src/components/Timeline/__tests__/Timeline.test.tsx`

**Steps:**
1. Failing test: renders section bands with proportional widths
2. TimelineTrack: horizontal ruler, each section band proportional to vh height
3. Band style: section color at 15% opacity, 2px bottom border, label centered
4. Width: `section.height / totalVh * trackWidth`
5. Wire: `sections` from store
6. Commit: `feat: implement TimelineTrack with section bands`

---

### Task 1D-2: Scrub Playhead

**Files:**
- Create: `src/components/Timeline/ScrubPlayhead.tsx`
- Modify: `src/components/Timeline/TimelineTrack.tsx`

**Steps:**
1. Vertical white line at `scrollProgress * trackWidth`
2. Click track → jump playhead
3. Drag playhead → continuous scrub (mousedown/mousemove/mouseup)
4. Wire: `scrollProgress`, `setScrollProgress`
5. Verify: timeline scrub updates viewport
6. Commit: `feat: add scrub playhead`

---

### Task 1D-3: Keyframe Markers

**Files:**
- Create: `src/components/Timeline/KeyframeMarker.tsx`
- Modify: `src/components/Timeline/TimelineTrack.tsx`

**Steps:**
1. 10x10px diamond (rotated 45deg) at keyframe scroll position
2. Default: `bg-gray-400`, Selected: `bg-indigo-400 ring-2`
3. Click → `selectKeyframe(id)` + `setScrollProgress(kf.scroll)`
4. Wire: `keyframes`, `selectedKeyframeId`
5. Commit: `feat: add keyframe markers`

---

### Task 1D-4: Keyframe Dragging

**Files:**
- Modify: `src/components/Timeline/KeyframeMarker.tsx`

**Steps:**
1. mousedown starts drag, mousemove updates scroll position
2. Clamp between adjacent keyframes (with small buffer)
3. mouseup commits
4. Wire: `updateKeyframe(id, { scroll })`
5. Commit: `feat: add keyframe dragging`

---

### Task 1D-5: Hold Zone Visualization

**Files:**
- Create: `src/components/Timeline/HoldZone.tsx`
- Modify: `src/components/Timeline/TimelineTrack.tsx`

**Steps:**
1. For `hold: true` keyframes, render bar to next keyframe
2. Style: `bg-indigo-500/20`, dashed borders, 4px height
3. Commit: `feat: add hold zone visualization`

---

### Task 1D-6: Context Menu (Keyframe CRUD)

**Files:**
- Create: `src/components/Timeline/TimelineContextMenu.tsx`
- Modify: `src/components/Timeline/TimelineTrack.tsx`

**Steps:**
1. Right-click track → "Add Keyframe Here"
2. Right-click marker → "Delete", "Duplicate", "Toggle Hold"
3. Add: interpolate current state, create keyframe
4. Delete: `removeKeyframe(id)`
5. Duplicate: copy at scroll + 0.02
6. Commit: `feat: add timeline context menu`

---

### Task 1D-7: Easing Preview

**Files:**
- Create: `src/components/Timeline/EasingPreview.tsx`
- Modify: `src/components/Timeline/TimelineTrack.tsx`

**Steps:**
1. SVG curve preview between keyframe pairs
2. Sample easing at 20 points, draw polyline
3. `stroke-gray-500 opacity-40`, 12px tall
4. Commit: `feat: add easing curve previews`

---

### Task 1D-8: Timeline Header + Add Button

**Files:**
- Modify: `src/components/Timeline/Timeline.tsx`

**Steps:**
1. Header: "Timeline" + scroll % + "+" add button
2. Scroll ruler: 0%, 25%, 50%, 75%, 100% marks
3. "+" adds keyframe at current playhead
4. Commit: `feat: add timeline header`

---

### Task 1D-9: Keyboard Shortcuts

**Files:**
- Modify: `src/components/Timeline/Timeline.tsx`

**Steps:**
1. Delete → remove selected keyframe
2. Ctrl+D → duplicate
3. Arrow Left/Right → nudge scroll by 0.01
4. Commit: `feat: add timeline keyboard shortcuts`

---

## Sub-Phase 1E: Properties Panel

### Context
The right panel (300px). Editable values for selected keyframe: model transforms, camera config, easing, description.

**Relevant skill:** `spyn-editor-ui`

### Task 1E-1: Panel Shell + Selection

**Files:**
- Modify: `src/components/PropertiesPanel/PropertiesPanel.tsx`

**Steps:**
1. Header "Properties", empty state when nothing selected
2. When keyframe selected: show scroll %, section name
3. Wire: `selectedKeyframeId`, `keyframes`
4. Commit: `feat: implement Properties Panel shell`

---

### Task 1E-2: Model Transform Controls

**Files:**
- Create: `src/components/PropertiesPanel/ModelTransformGroup.tsx`
- Modify: `src/components/PropertiesPanel/PropertiesPanel.tsx`

**Steps:**
1. PropertyGroup "Model Transform":
   - Position: XYZInput (X: vw 0-100, Y: vh 0-100, Z: depth)
   - Rotation: XYZInput (degrees)
   - Scale: NumericInput
   - Opacity: NumericInput (0-1)
2. Wire: `updateKeyframe(id, { model: { ...updated } })`
3. Commit: `feat: add model transform controls`

---

### Task 1E-3: Camera Controls

**Files:**
- Create: `src/components/PropertiesPanel/CameraGroup.tsx`
- Modify: `src/components/PropertiesPanel/PropertiesPanel.tsx`

**Steps:**
1. PropertyGroup "Camera":
   - Orbit (0-360), Elevation (-90 to 90), Distance, FOV, Offset X/Y
2. Wire: `updateKeyframe(id, { camera: { ...updated } })`
3. Commit: `feat: add camera controls`

---

### Task 1E-4: Easing Selector

**Files:**
- Create: `src/components/PropertiesPanel/EasingSelector.tsx`
- Modify: `src/components/PropertiesPanel/PropertiesPanel.tsx`

**Steps:**
1. Select with 16 easing functions grouped by family
2. Small SVG preview of curve shape
3. Wire: `updateKeyframe(id, { easeFrom })`
4. Commit: `feat: add easing selector`

---

### Task 1E-5: Description Field

**Files:**
- Modify: `src/components/PropertiesPanel/PropertiesPanel.tsx`

**Steps:**
1. Textarea for `description` with placeholder
2. Warning icon when empty (critical for Claude Code handoff)
3. Wire: `updateKeyframe(id, { description })`
4. Commit: `feat: add description field`

---

### Task 1E-6: Hold Toggle + Scroll Position

**Files:**
- Modify: `src/components/PropertiesPanel/PropertiesPanel.tsx`

**Steps:**
1. Checkbox "Hold at this keyframe"
2. NumericInput for exact scroll position (0-1, step 0.01)
3. Wire both to `updateKeyframe`
4. Commit: `feat: add hold toggle and scroll position input`

---

### Task 1E-7: Properties Polish

**Files:**
- Modify: all PropertiesPanel components

**Steps:**
1. Verify all inputs update viewport in real-time
2. Proper scroll overflow for long property lists
3. Run all tests
4. Commit: `feat: polish Properties Panel`

---

## Sub-Phase 1F: Export, Save/Load & Integration

### Context
Wire YAML export, project save/load, and final integration. The YAML export util already exists — this adds UI and validation.

**Relevant skill:** `spyn-yaml-export`

### Task 1F-1: Validation

**Files:**
- Create: `src/utils/validation.ts`
- Create: `src/utils/__tests__/validation.test.ts`

**Steps:**
1. `validateProject(project)` checking all required fields, ranges, references
2. Tests for each rule
3. Commit: `feat: add project validation`

---

### Task 1F-2: Export Modal

**Files:**
- Create: `src/components/Export/ExportModal.tsx`
- Create: `src/components/Export/ExportButton.tsx`

**Steps:**
1. ExportButton triggers validation + shows modal
2. Modal: errors/warnings, YAML preview, Download + Copy buttons
3. Commit: `feat: add export modal`

---

### Task 1F-3: Project Save/Load

**Files:**
- Create: `src/utils/projectStorage.ts`
- Create: `src/utils/__tests__/projectStorage.test.ts`

**Steps:**
1. Save/load/list/delete via localStorage
2. Tests with mocked localStorage
3. Commit: `feat: add project save/load`

---

### Task 1F-4: Project Menu

**Files:**
- Create: `src/components/ProjectMenu/ProjectMenu.tsx`
- Modify: `src/App.tsx` (add header bar)

**Steps:**
1. Thin header bar: project name + New/Save/Load/Rename
2. Wire to projectStorage utils
3. Commit: `feat: add project menu`

---

### Task 1F-5: Integration Test

**Files:**
- Create: `src/__tests__/integration.test.ts`

**Steps:**
1. Full workflow: create sections → add keyframes → update transforms → export YAML → validate
2. Run full test suite
3. Commit: `test: add integration test`

---

### Task 1F-6: Final Polish

**Files:**
- Various

**Steps:**
1. All panels render correctly together
2. Scrubbing updates viewport in real-time
3. Selection syncs between timeline/properties
4. `npm run build` succeeds
5. All tests pass
6. Update CLAUDE.md
7. Commit: `feat: Phase 1 MVP complete`

---

## Verification Plan

### Manual End-to-End Test
1. Start dev server, open browser
2. **Sections:** Add Hero, Features, CTA. Reorder. Adjust heights.
3. **Viewport:** Purple cube visible. Edit mode shows grid. Preview mode is clean.
4. **Timeline:** Section bands appear proportional. Click to move playhead. Scroll % updates.
5. **Keyframes:** Right-click → Add at 0.0, 0.5, 1.0. Diamonds appear.
6. **Properties:** Click keyframe. Change position/camera. Viewport updates immediately.
7. **Hold:** Toggle hold. Indigo bar in timeline.
8. **Export:** Click Export. Validation runs. Download YAML. Verify contents.
9. **Save/Load:** Save, refresh, load. All state restored.

### Automated Tests
Run: `npm test -- --run` — all unit + integration tests pass.

---

## Future Phases (Not in Scope)

### Phase 2 — Power Features
Per-property tracks, bezier easing editor, split/explode, material swap, animation presets, spec diff export, responsive editor, physics settings, file-based save/load.

### Phase 3 — Product
UI polish, docs, npm runtime package, landing page, community presets.
